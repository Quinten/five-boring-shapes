<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Puzzle 6</title>
    <meta name="description" content="minimalistic puzzle game">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#5C9996">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        html, body { height: 100%; position: relative; overflow: hidden; background: #5C9996; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        canvas { position: relative; display: block; }
    </style>
</head>
<body>
<script>

let score = Number(localStorage.getItem('puzzle-6-score'));
let hiscore = Number(localStorage.getItem('puzzle-6-hiscore'));

let canvas = document.createElement('canvas');
document.body.appendChild(canvas);

// the 2d drawing api
let ctx = canvas.getContext('2d');
//console.log(ctx);

// resize canvas with window
let w = 320;
let h = 320;
let resizeTOID = 0;
let onR = e => {
    clearTimeout(resizeTOID);
    resizeTOID = setTimeout(_ => {
        canvas.width = w = window.innerWidth * window.devicePixelRatio;
        canvas.height = h = window.innerHeight * window.devicePixelRatio;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
    }, 40);
};
onR();
window.addEventListener('resize', onR);

// init
let u = 48 * window.devicePixelRatio;
let shapes = [
    time => {
        ctx.rotate(Math.PI / 4);
        let v = Math.hypot(u / 2, u / 2) - 4 * window.devicePixelRatio;
        ctx.fillRect(-v / 2, - v / 2, v, v);
    },
    time => {
        let v = u - 8 * window.devicePixelRatio;
        ctx.beginPath();
        ctx.arc(0, 0, v / 2, 0, 2 * Math.PI);
        ctx.fill();
    },
    time => {
        let v = u - 8 * window.devicePixelRatio;
        let z = Math.sqrt(v * v - (v/2)*(v/2));
        ctx.beginPath();
        ctx.moveTo(-v/2, z/2);
        ctx.lineTo(v/2, z/2);
        ctx.lineTo(0, -z/2);
        ctx.closePath();
        ctx.fill();
    },
    time => {
        let v = u - 8 * window.devicePixelRatio;
        let size = v / 2;
        ctx.beginPath();
        ctx.moveTo(size * Math.cos(0), size * Math.sin(0));
        for (let side = 0; side < 7; side++) {
            ctx.lineTo(
                size * Math.cos(side * 2 * Math.PI / 6),
                size * Math.sin(side * 2 * Math.PI / 6)
            );
        }
        ctx.fill();
    },
    time => {
        let v = u - 8 * window.devicePixelRatio;
        let size = v / 2;
        ctx.beginPath();
        ctx.moveTo(size * Math.cos(- Math.PI / 2), size * Math.sin(- Math.PI / 2));
        for (let side = 0; side < 6; side++) {
            ctx.lineTo(
                size * Math.cos(side * 2 * Math.PI / 5 - Math.PI / 2),
                size * Math.sin(side * 2 * Math.PI / 5 - Math.PI / 2)
            );
        }
        ctx.fill();
    }
];

let gridWidth = 6;
let gridHeight = 6;

let blocks = [];
let blocksData = localStorage.getItem('puzzle-6-blocks');
if (blocksData !== null) {
    blocks = JSON.parse(blocksData);
    blocks = blocks.map(block => (block === null) ? undefined : block);
}

let resetBlocks = _ => {

    blocks = [];

    let shape = Math.floor(
        Math.random() * shapes.length
    );

    while (blocks.length < gridWidth * gridHeight) {
        let x = blocks.length % gridWidth;
        let y = blocks.length / gridWidth | 0;
        if (Math.random() > .5) {
            shape = Math.floor(
                Math.random() * shapes.length
            );
        }
        let oldY = y;
        let startAni = false;
        let endTime = 0;
        let frozen = false;
        let block = { x, y, oldY, startAni, endTime, shape, frozen };
        blocks.push(block);
    }
    localStorage.setItem('puzzle-6-blocks', JSON.stringify(blocks));
    if (score > hiscore) {
        hiscore = score;
        localStorage.setItem('puzzle-6-hiscore', hiscore);
    }
    score = 0;
    localStorage.setItem('puzzle-6-score', score);
};

if (blocks.length === 0) {
    resetBlocks();
}

let muted = true;

// animation loop
let onF = time => {

    // clear canvas
    ctx.save();
    ctx.fillStyle = '#5C9996';
    ctx.fillRect(0, 0, w, h);
    ctx.restore();

    // draw blocks
    blocks.forEach(block => {
        if (block === undefined) {
            return;
        }
        ctx.save();
        let y = block.y;
        if (block.startAni) {
            block.startAni = false;
            block.endTime = time + 750;
        }
        if (block.endTime > time) {
            y = block.oldY + (block.y - block.oldY) * easeOutBounce(1 + (time - block.endTime) / 750);
        } else {
            block.oldY = y;
        }

        ctx.translate(
           w/2 - gridWidth*u/2 + u/2 + block.x*u,
           h/2 - gridHeight*u/2 + u/2 + y*u,
        );
        ctx.fillStyle = (block.frozen) ? '#9AC1C0' : '#F4ECD6';
        shapes[block.shape](time);
        ctx.restore();
    });

    ctx.save();
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillStyle = '#F4ECD6';
    let fontSize = 12 * window.devicePixelRatio;
    ctx.font = fontSize + 'px monospace';
    ctx.fillText('Hiscore: ' + hiscore, 4 * window.devicePixelRatio, 4 * window.devicePixelRatio);
    ctx.fillText('Score: ' + score, 4 * window.devicePixelRatio, 20 * window.devicePixelRatio);
    if (gameover) {
        ctx.textAlign = 'center';
        fontSize = 32 * window.devicePixelRatio;
        ctx.font = fontSize + 'px monospace';
        ctx.fillText('GAME OVER', w / 2, (h - u) / 2);
        fontSize = 16 * window.devicePixelRatio;
        ctx.font = fontSize + 'px monospace';
        ctx.fillText('tap to restart', w / 2, (h + u) / 2);
    }
    // soundbutton
    let svgPath = 'M20.159,6.661L11.818,15L2.25,15C1.007,15 0,16.007 0,17.25L0,30.75C0,31.992 1.007,33 2.25,33L11.818,33L20.159,41.339C21.568,42.748 24,41.758 24,39.748L24,8.252C24,6.24 21.566,5.254 20.159,6.661ZM45,24C45,18.044 41.994,12.568 36.959,9.352C35.91,8.683 34.519,8.994 33.854,10.052C33.189,11.109 33.5,12.509 34.549,13.179C38.275,15.56 40.5,19.604 40.5,24C40.5,28.396 38.275,32.44 34.549,34.821C33.5,35.49 33.189,36.89 33.854,37.948C34.464,38.919 35.834,39.368 36.959,38.648C41.994,35.432 45,29.957 45,24ZM31.709,16.793C30.623,16.2 29.254,16.591 28.652,17.679C28.053,18.768 28.449,20.136 29.538,20.737C30.748,21.401 31.5,22.653 31.5,24C31.5,25.348 30.748,26.599 29.539,27.263C28.45,27.864 28.054,29.232 28.653,30.321C29.256,31.414 30.626,31.802 31.71,31.207C34.357,29.749 36.001,26.988 36.001,23.999C36.001,21.01 34.357,18.25 31.709,16.793Z';
    if (muted) = {
        svgPath = 'M20.159,6.661L11.818,15L2.25,15C1.007,15 0,16.007 0,17.25L0,30.75C0,31.992 1.007,33 2.25,33L11.818,33L20.159,41.339C21.568,42.748 24,41.758 24,39.748L24,8.252C24,6.24 21.566,5.254 20.159,6.661ZM43.279,24L47.558,19.721C48.148,19.131 48.148,18.173 47.558,17.582L45.418,15.443C44.828,14.852 43.869,14.852 43.279,15.443L39,19.721L34.721,15.443C34.131,14.852 33.173,14.852 32.582,15.443L30.443,17.582C29.852,18.173 29.852,19.131 30.443,19.721L34.721,24L30.443,28.278C29.853,28.869 29.853,29.827 30.443,30.417L32.583,32.557C33.173,33.147 34.132,33.147 34.722,32.557L39,28.279L43.279,32.558C43.869,33.148 44.828,33.148 45.418,32.558L47.558,30.418C48.148,29.828 48.148,28.87 47.558,28.279L43.279,24Z';
    }
    //
    //let p = new Path2D('M10 10 h 80 v 80 h -80 Z');
    //ctx.fill(p);


    ctx.restore();
    // request next frame
    requestAnimationFrame(onF);
};
setTimeout(onF, 50, 0);

// pointer events
// mousedown | mousemove | mouseup
// touchstart | touchmove | touchend

canvas.addEventListener('mousedown', e => {

    let pointerX = e.clientX * window.devicePixelRatio;
    let pointerY = e.clientY * window.devicePixelRatio;

    handlePointer(pointerX, pointerY);

});

canvas.addEventListener('touchstart', e => {

    e.preventDefault(); // this prevents mousedown from firing

    let pointerX = e.changedTouches[0].clientX * window.devicePixelRatio;
    let pointerY = e.changedTouches[0].clientY * window.devicePixelRatio;

    handlePointer(pointerX, pointerY);

});

let gameover = false;

let handlePointer = (pointerX, pointerY) => {
    if (gameover) {
        gameover = false;
        resetBlocks();
        return;
    }
    let index = blocks.findIndex(block => {
        if (block === undefined) {
            return false;
        }
        let x = w/2 - gridWidth*u/2 + block.x*u;
        let y = h/2 - gridHeight*u/2 + block.y*u;
        return !(pointerX < x || pointerY < y || pointerX > x + u || pointerY > y + u);
    });
    if (index > -1) {
        if (blocks[index] !== undefined) {
            let matches = checkBlock(
                index,
                blocks[index].shape,
                blocks[index].frozen
            );
            if (matches.length > 1) {
                score = score + matches.length * matches.length;
                localStorage.setItem('puzzle-6-score', score);
                beep(blocks[index].shape);
                // remove connected shapes
                matches.forEach(toRM => {
                    blocks[toRM] = undefined;
                });
                // drop everything down
                let x = 0;
                while (x < gridWidth) {
                    let y = gridHeight - 2;
                    while (y > -1) {
                        let pos = y * gridWidth + x;
                        let bottom = (y + 1) * gridWidth + x;
                        if (y < gridHeight - 1 && blocks[pos] !== undefined && blocks[bottom] === undefined) {
                            blocks[bottom] = blocks[pos];
                            blocks[bottom].x = x;
                            blocks[bottom].y = y + 1;
                            blocks[bottom].startAni = true;
                            blocks[pos] = undefined;
                            y = y + 1;
                        } else {
                           y = y - 1;
                        }
                    }
                    x = x + 1;
                }
                // check needs refill
                if (!blocks.some((block, index) => block !== undefined && checkBlock(index, block.shape, false).length > 1)) {
                    // freeze leftovers
                    blocks = blocks.map(
                        (block, index) => {
                            if (block !== undefined) {
                               block.frozen = true;
                            }
                            return block;
                    });
                    // check game over
                    if (blocks.some((block, index) => block !== undefined && block.frozen && index < gridWidth)) {
                        if (blocks.some((block, index) => block !== undefined && checkBlock(index, block.shape, block.frozen).length > 1)) {
                            localStorage.setItem('puzzle-6-blocks', JSON.stringify(blocks));
                            return;
                        }
                        gameover = true;
                        localStorage.setItem('puzzle-6-blocks', JSON.stringify([]));
                        return;
                    }
                    let newShape = Math.floor(
                        Math.random() * shapes.length
                    );
                    blocks = blocks.map(
                        (block, index) => {
                            if (block !== undefined) {
                               block.frozen = true;
                               newShape = block.shape;
                               return block;
                            }
                            let x = index % gridWidth;
                            let y = index / gridWidth | 0;
                            let shape = newShape;
                            if (x !== gridWidth - 1) {
                                if (blocks[index + 1] !== undefined && blocks[index + 1].frozen) {
                                    shape = blocks[index + 1].shape;
                                }
                            }
                            if (blocks[index - 1] !== undefined && blocks[index - 1].frozen || Math.random() > .5) {
                                newShape = (shape + 1) % shapes.length;
                            }
                            let oldY = y - 2;
                            let startAni = true;
                            let endTime = 0;
                            let frozen = false;
                            return { x, y, oldY, startAni, endTime, shape, frozen };
                        }
                    );
                }
                localStorage.setItem('puzzle-6-blocks', JSON.stringify(blocks));
            }
        }
    }
};

let checkBlock = (index, shape, frozen) => {
    let matches = [];
    let checkConnection = (index, shape, frozen) => {
        if (
            blocks[index] === undefined ||
            blocks[index].shape !== shape ||
            blocks[index].frozen !== frozen ||
            matches.indexOf(index) > -1
        ) {
            return;
        }
        matches.push(index);
        checkConnection(index - gridWidth, shape, frozen),
        checkConnection(index + gridWidth, shape, frozen);
        if (index % gridWidth !== 0) {
            checkConnection(index - 1, shape, frozen);
        }
        if (index % gridWidth !== gridWidth - 1) {
            checkConnection(index + 1, shape, frozen);
        }
    };
    checkConnection(index, shape, frozen);
    return matches;
};


// music/sound

let playSong = (options = {}) => {

    let notes = 'AbBCdDeEFgGa';

    let playNote = (node, note, start, bpm = 120, shape = 'square') => {

        if (node.context.state === 'closed') {
            return;
        }

        let noteName = note.replace(/\d/g, '');
        let noteRate = note.match(/^\d+/g);
        noteRate = (noteRate) ? +noteRate[0] : 4;
        let octave = note.match(/\d+$/g);
        octave = (octave) ? +octave[0] : 4;

        let length = 15 / bpm * noteRate;

        let noteIndex = notes.indexOf(noteName);
        if (noteIndex === -1) {
            // a pause in between the notes
            return length;
        }

        let detune = noteIndex * 100 + 1200 * (octave - 4);

        let o = node.context.createOscillator();
        o.connect(node);

        o.frequency.value = 440;
        o.detune.value = detune;
        o.type = shape;

        node.gain.setValueAtTime(0, start);
        node.gain.linearRampToValueAtTime(0.2, start + length * 0.03);
        node.gain.setValueAtTime(0.2, start + length * 0.3);
        node.gain.linearRampToValueAtTime(0, start + length * 1.5);

        o.start(start);
        o.stop(start + length * 1.5);

        return length;
    };

    let {melody, bass, bpm = 120, shuffle = false, loop = true} = options;

    if (shuffle) {
        rnd = Math.random;
        melody = shuffleArray(melody);
        bass = shuffleArray(bass);
    }

    let mLooped = false;
    let bLooped = false;

    let ctx = new AudioContext();

    let biquadFilter = ctx.createBiquadFilter();
    biquadFilter.connect(ctx.destination);
    biquadFilter.type = 'lowpass';
    biquadFilter.frequency.value = 920;
    //biquadFilter.gain.value = 25;

    let musicVolume = ctx.createGain();
    musicVolume.connect(biquadFilter);
    musicVolume.gain.value = 0.5;

    let delayEffect = ctx.createDelay(60 / bpm);
    delayEffect.delayTime.value = 60 / bpm;
    let delayVolume = ctx.createGain();
    delayVolume.gain.value = 0.15;
    delayVolume.connect(musicVolume);
    delayEffect.connect(delayVolume);

    let noteNodes = [0, 1, 2, 3, 4, 5, 6, 7].map(() => {
        let node = ctx.createGain();
        node.connect(musicVolume);
        node.connect(delayEffect);
        return node;
    });

    let index = 0;

    let nextNote = 0;
    let nextNoteTick = 0;

    let nextPluck = 0;
    let nextPluckTick = 0;

    let anticipate = 60 / bpm * 7;

    let scheduleNotes = () => {
        if (ctx.state === 'closed') {
            return;
        }
        if (ctx.currentTime > nextNoteTick + 1 || ctx.currentTime > nextPluckTick + 1) {
            if (loop || (bass && !bLooped) || (melody && !mLooped)) {
                nextNote = 0;
                nextPluck = 0;
                nextNoteTick = nextPluckTick = ctx.currentTime;
            } else {
                ctx.close();
            }
        }
        if (melody && (loop || !mLooped)) {
            if (ctx.currentTime > nextNoteTick - anticipate) {
                let noteLength = playNote(noteNodes[index], melody[nextNote], nextNoteTick, bpm, 'square');
                index = (index + 1) % noteNodes.length;
                nextNote = (nextNote + 1) % melody.length;
                nextNoteTick += noteLength;
                if (nextNote === 0) {
                    if (shuffle) {
                        melody = shuffleArray(melody);
                    }
                    mLooped = true;
                }
            }
        }
        if (bass && (loop || !bLooped)) {
            if (ctx.currentTime > nextPluckTick - anticipate) {
                let pluckLength = playNote(noteNodes[index], bass[nextPluck], nextPluckTick, bpm, 'triangle');
                index = (index + 1) % noteNodes.length;
                nextPluck = (nextPluck + 1) % bass.length;
                nextPluckTick += pluckLength;
                if (nextPluck === 0) {
                    if (shuffle) {
                        bass = shuffleArray(bass);
                    }
                    bLooped = true;
                }
            }
        }
        requestAnimationFrame(scheduleNotes);
    };
    scheduleNotes();

    return ctx;
};

let rnd = Math.random; // todo add a prng

let shuffleArray = (arr) => {
    let newArr = [];
    let oldArr = [...arr];
    while (oldArr.length) {
        newArr.push(oldArr.splice(
            Math.floor(rnd() * oldArr.length),
            1
        )[0]);
    }
    return newArr;
};

let beep = (tune = 0) => {
    let bpm = 138;
    let tunes = ['2C4', '2e4', '2a4', '2G4', '2B4'];
    let melody = [tunes[tune]];
    //let melody = ['2C4'];
    //let bass = ['2C2'];
    let loop = false;
    playSong({melody, bpm, loop});
};

let easeOutBounce = x => {
    let n1 = 7.5625;
    let d1 = 2.75;

    if (x < 1 / d1) {
        return n1 * x * x;
    } else if (x < 2 / d1) {
        return n1 * (x -= 1.5 / d1) * x + 0.75;
    } else if (x < 2.5 / d1) {
        return n1 * (x -= 2.25 / d1) * x + 0.9375;
    } else {
        return n1 * (x -= 2.625 / d1) * x + 0.984375;
    }
}

if ('serviceWorker' in navigator) {
    window.addEventListener('load', e => {
        navigator.serviceWorker.register('./sw.js').then(registration => {
            //console.log('ServiceWorker registration successful with scope: ', registration.scope);
        }, err => {
            //console.log('ServiceWorker registration failed: ', err);
        });
    });
}

</script>
</body>
</html>
