<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Game name</title>
    <meta name="description" content="A game description">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="teal">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        html, body { height: 100%; position: relative; overflow: hidden; background: teal; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        canvas { position: relative; display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
<script>

let canvas = document.createElement('canvas');
document.body.appendChild(canvas);

// the 2d drawing api
let ctx = canvas.getContext('2d');
//console.log(ctx);

// resize canvas with window
let w;
let h;
let resizeTOID = 0;
let onR = e => {
    clearTimeout(resizeTOID);
    resizeTOID = setTimeout(_ => {
        canvas.width = w = window.innerWidth * window.devicePixelRatio;
        canvas.height = h = window.innerHeight * window.devicePixelRatio;
    }, 40);
};
onR();
window.addEventListener('resize', onR);

// init
let u = 48 * window.devicePixelRatio;
let shapeVisible = true;
let shapes = [
    time => {
        ctx.rotate(Math.PI / 4);
        let v = Math.hypot(u / 2, u / 2) - 4 * window.devicePixelRatio;
        ctx.fillRect(-v / 2, - v / 2, v, v);
    },
    time => {
        let v = u - 8*window.devicePixelRatio;
        ctx.beginPath();
        ctx.arc(0, 0, v / 2, 0, 2 * Math.PI);
        ctx.fill();
    },
    time => {
        let v = u - 8*window.devicePixelRatio;
        let z = Math.sqrt(v * v - (v/2)*(v/2));
        ctx.beginPath();
        ctx.moveTo(-v/2, z/2);
        ctx.lineTo(v/2, z/2);
        ctx.lineTo(0, -z/2);
        ctx.closePath();
        ctx.fill();
    }
];

let gridWidth = 6;
let gridHeight = 6;

let blocks = [];

while (blocks.length < gridWidth * gridHeight) {
    let x = blocks.length % gridWidth;
    let y = blocks.length / gridWidth | 0;
    let shape = Math.floor(
        Math.random() * shapes.length
    );
    let block = { x, y, shape };
    blocks.push(block);
}


// animation loop
let onF = time => {

    // clear canvas
    ctx.save();
    ctx.fillStyle = 'teal';
    ctx.fillRect(0, 0, w, h);   
    ctx.restore();

    // draw blocks
    blocks.forEach(block => {
        if (block === undefined) {
            return;
        }
        ctx.save();
        ctx.translate(
           w/2 - gridWidth*u/2 + u/2 + block.x*u,
           h/2 - gridHeight*u/2 + u/2 + block.y*u,
        );
        ctx.fillStyle = (shapeVisible) ? 'snow' : 'turquoise';
        shapes[block.shape](time);
        ctx.restore();
    });

    // request next frame
    requestAnimationFrame(onF);
};
setTimeout(onF, 50, 0);

// pointer events
// mousedown | mousemove | mouseup
// touchstart | touchmove | touchend

canvas.addEventListener('mousedown', e => {

    let pointerX = e.clientX * window.devicePixelRatio;
    let pointerY = e.clientY * window.devicePixelRatio;
    
    handlePointer(pointerX, pointerY);

    //shapeVisible = !shapeVisible;

    //beep();

});

canvas.addEventListener('touchstart', e => {

    e.preventDefault(); // this prevents the mousedown from firing

    let pointerX = e.changedTouches[0].clientX * window.devicePixelRatio;
    let pointerY = e.changedTouches[0].clientY * window.devicePixelRatio;
    
    handlePointer(pointerX, pointerY);

    //shapeVisible = !shapeVisible;

    //beep();

});

let handlePointer = (pointerX, pointerY) => {
    let index = blocks.findIndex(block => {
        if (block === undefined) {
            return false;
        }
        let x = w/2 - gridWidth*u/2 + block.x*u;
        let y = h/2 - gridHeight*u/2 + block.y*u;
        return !(pointerX < x || pointerY < y || pointerX > x + u || pointerY > y + u);
    });
    if (index > -1) {
        if (blocks[index] !== undefined) {
            let matches = checkConnection(
                index,
                blocks[index].shape
            );
            if (matches.length > 1) {
                matches.forEach(toRM => {
                    blocks[toRM] = undefined;
                });
                let x = 0;
                while (x < gridWidth) {
                    let y = gridHeight - 2;
                    while (y > -1) {
                        let pos = y * gridWidth + x;
                        let bottom = (y + 1) * gridWidth + x;
                        if (y < gridHeight - 1 && blocks[pos] !== undefined && blocks[bottom] === undefined) {
                            blocks[bottom] = blocks[pos];
                            blocks[bottom].x = x;
                            blocks[bottom].y = y + 1;
                            blocks[pos] = undefined;
                            y = y + 1;
                        } else {
                           y = y - 1;
                        }
                    }
                    x = x + 1;
                }
            }
        }
    }
};

let checkConnection = (index, shape, matches = []) => {
    if (blocks[index] === undefined || blocks[index].shape !== shape || matches.indexOf(index) > -1) {
        return [];
    }
    matches.push(index);
    matches = matches.concat(
        checkConnection(index - gridWidth, shape, matches),
        checkConnection(index + gridWidth, shape, matches));
    if (index % gridWidth !== 0) {
        matches = matches.concat(checkConnection(index - 1, shape, matches));
    }
    if (index % gridWidth !== gridWidth - 1) {
        matches = matches.concat(checkConnection(index + 1, shape, matches));
    }
    return matches;
};

// music/sound

let playSong = (options = {}) => {

    let notes = 'AbBCdDeEFgGa';

    let playNote = (node, note, start, bpm = 120, shape = 'square') => {

        if (node.context.state === 'closed') {
            return;
        }

        let noteName = note.replace(/\d/g, '');
        let noteRate = note.match(/^\d+/g);
        noteRate = (noteRate) ? +noteRate[0] : 4;
        let octave = note.match(/\d+$/g);
        octave = (octave) ? +octave[0] : 4;

        let length = 15 / bpm * noteRate;

        let noteIndex = notes.indexOf(noteName);
        if (noteIndex === -1) {
            // a pause in between the notes
            return length;
        }

        let detune = noteIndex * 100 + 1200 * (octave - 4);

        let o = node.context.createOscillator();
        o.connect(node);

        o.frequency.value = 440;
        o.detune.value = detune;
        o.type = shape;

        node.gain.setValueAtTime(0, start);
        node.gain.linearRampToValueAtTime(0.2, start + length * 0.03);
        node.gain.setValueAtTime(0.2, start + length * 0.3);
        node.gain.linearRampToValueAtTime(0, start + length * 1.5);

        o.start(start);
        o.stop(start + length * 1.5);

        return length;
    };

    let {melody, bass, bpm = 120, shuffle = false, loop = true} = options;

    if (shuffle) {
        rnd = Math.random;
        melody = shuffleArray(melody);
        bass = shuffleArray(bass);
    }

    let mLooped = false;
    let bLooped = false;

    let ctx = new AudioContext();

    let biquadFilter = ctx.createBiquadFilter();
    biquadFilter.connect(ctx.destination);
    biquadFilter.type = 'lowpass';
    biquadFilter.frequency.value = 920;
    //biquadFilter.gain.value = 25;

    let musicVolume = ctx.createGain();
    musicVolume.connect(biquadFilter);
    musicVolume.gain.value = 0.5;

    let delayEffect = ctx.createDelay(60 / bpm);
    delayEffect.delayTime.value = 60 / bpm;
    let delayVolume = ctx.createGain();
    delayVolume.gain.value = 0.15;
    delayVolume.connect(musicVolume);
    delayEffect.connect(delayVolume);

    let noteNodes = [0, 1, 2, 3, 4, 5, 6, 7].map(() => {
        let node = ctx.createGain();
        node.connect(musicVolume);
        node.connect(delayEffect);
        return node;
    });

    let index = 0;

    let nextNote = 0;
    let nextNoteTick = 0;

    let nextPluck = 0;
    let nextPluckTick = 0;

    let anticipate = 60 / bpm * 7;

    let scheduleNotes = () => {
        if (ctx.state === 'closed') {
            return;
        }
        if (ctx.currentTime > nextNoteTick + 1 || ctx.currentTime > nextPluckTick + 1) {
            if (loop || (bass && !bLooped) || (melody && !mLooped)) {
                nextNote = 0;
                nextPluck = 0;
                nextNoteTick = nextPluckTick = ctx.currentTime;
            } else {
                ctx.close();
            }
        }
        if (melody && (loop || !mLooped)) {
            if (ctx.currentTime > nextNoteTick - anticipate) {
                let noteLength = playNote(noteNodes[index], melody[nextNote], nextNoteTick, bpm, 'square');
                index = (index + 1) % noteNodes.length;
                nextNote = (nextNote + 1) % melody.length;
                nextNoteTick += noteLength;
                if (nextNote === 0) {
                    if (shuffle) {
                        melody = shuffleArray(melody);
                    }
                    mLooped = true;
                }
            }
        }
        if (bass && (loop || !bLooped)) {
            if (ctx.currentTime > nextPluckTick - anticipate) {
                let pluckLength = playNote(noteNodes[index], bass[nextPluck], nextPluckTick, bpm, 'triangle');
                index = (index + 1) % noteNodes.length;
                nextPluck = (nextPluck + 1) % bass.length;
                nextPluckTick += pluckLength;
                if (nextPluck === 0) {
                    if (shuffle) {
                        bass = shuffleArray(bass);
                    }
                    bLooped = true;
                }
            }
        }
        requestAnimationFrame(scheduleNotes);
    };
    scheduleNotes();

    return ctx;
};

let rnd = Math.random; // todo add a prng

let shuffleArray = (arr) => {
    let newArr = [];
    let oldArr = [...arr];
    while (oldArr.length) {
        newArr.push(oldArr.splice(
            Math.floor(rnd() * oldArr.length),
            1
        )[0]);
    }
    return newArr;
};

let beep = _ => {
    let bpm = 138;
    let melody = ['2C4'];
    //let bass = ['2C2'];
    let loop = false;
    playSong({melody, bpm, loop});
};

if ('serviceWorker' in navigator) {
    window.addEventListener('load', e => {
        navigator.serviceWorker.register('./sw.js').then(registration => {
            //console.log('ServiceWorker registration successful with scope: ', registration.scope);
        }, err => {
            //console.log('ServiceWorker registration failed: ', err);
        });
    });
}

</script>
</body>
</html>
